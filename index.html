<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DayZ CCG - Spectator View</title>
  <link rel="stylesheet" href="styles/spectator.css">

  <!-- ‚úÖ Silence icon-related 404s by using local assets that exist -->
  <link rel="icon" href="images/cards/000_CardBack_Unique.png">
  <link rel="icon" type="image/png" sizes="32x32" href="images/cards/000_CardBack_Unique.png">
  <link rel="icon" type="image/png" sizes="192x192" href="images/cards/000_CardBack_Unique.png">
  <link rel="apple-touch-icon" href="images/cards/000_CardBack_Unique.png">

  <style>
    /* üîä Tiny audio toggle */
    .audio-toggle {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 9999;
      background: rgba(0,0,0,0.65);
      color: #fff;
      border: 1px solid #00ffff;
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
      backdrop-filter: blur(2px);
    }
    .audio-toggle:hover { box-shadow: 0 0 10px #00ffff; }

    /* simple inline styles for the piles row (uses classes, not IDs) */
    .piles { margin: 6px 0 10px; color: #cfe9ff; font-size: 13px; opacity: 0.9; }
    .piles strong { font-weight: 700; }
  </style>

  <!-- üåê Token/API boot; expose to scripts and persist token -->
  <script>
    (function () {
      const qs = new URLSearchParams(location.search);
      const tokenFromUrl = qs.get('token') || '';
      const apiFromUrl = (qs.get('api') || '').replace(/\/+$/, '');

      // Persist/reuse token across UIs
      let token = tokenFromUrl;
      try {
        if (!token) token = localStorage.getItem('sv13.token') || '';
        if (tokenFromUrl) localStorage.setItem('sv13.token', tokenFromUrl);
      } catch {}

      // Globals for any scripts (e.g., spectatorview.js)
      window.PLAYER_TOKEN = token;
      window.API_BASE = apiFromUrl || '/api';
      try { console.log('[Spectator] API_BASE =', window.API_BASE); } catch {}
    })();
  </script>

  <!-- üßΩ Net hygiene: installs global fetch/backoff guards BEFORE any network-using scripts -->
  <script src="scripts/net-hygiene.js" defer></script>
</head>
<body>
  <div id="background"></div>

  <!-- üß± Two-column layout: main content + right chat panel -->
  <div class="page">
    <!-- Main spectator column (all your existing content) -->
    <main id="spectator-main">
      <div class="spectator-header">
        <h1>Spectator View</h1>
        <p id="spectator-status">Waiting for match...</p>
        <p id="watching-count">Spectators Watching: 0</p>
      </div>

      <p id="turn-display" style="text-align:center; color:white; font-size:18px;"></p>

      <div class="duel-container">
        <!-- Opponent / Bot -->
        <div class="player" id="player2">
          <h2 id="player2-name">Opponent</h2>
          <div class="hp">HP: <span id="player2-hp">200</span></div>
          <div class="piles">
            Deck: <strong class="deck-count">0</strong> ‚Ä¢
            Discard: <strong class="discard-count">0</strong>
          </div>
          <div class="field" id="player2-field"></div>
          <div class="hand" id="player2-hand"></div>
        </div>

        <!-- Challenger / Player1 -->
        <div class="player" id="player1">
          <h2 id="player1-name">Challenger</h2>
          <div class="hp">HP: <span id="player1-hp">200</span></div>
          <div class="piles">
            Deck: <strong class="deck-count">0</strong> ‚Ä¢
            Discard: <strong class="discard-count">0</strong>
          </div>
          <div class="field" id="player1-field"></div>
          <div class="hand" id="player1-hand"></div>
        </div>
      </div>
    </main>

    <!-- ‚≠ê New: Spectator Chat right column -->
    <aside id="chat-panel" aria-label="Spectator chat">
      <header class="chat-header">
        <div class="chat-title">Live Chat</div>
        <div id="chat-presence" class="chat-presence">0 online</div>
      </header>

      <div id="chat-log" class="chat-log" role="log" aria-live="polite"></div>
      <div id="chat-typing" class="chat-typing" aria-live="polite"></div>

      <!-- prevent full page reload even if the module fails to attach -->
      <form id="chat-form" class="chat-form" autocomplete="off" onsubmit="event.preventDefault()">
        <input id="chat-input" type="text" placeholder="Message the crowd‚Ä¶" maxlength="500" />
        <button id="chat-send" type="submit" aria-label="Send message">Send</button>
      </form>
    </aside>
  </div>

  <!-- üîî Join toast mount (content injected via JS) -->
  <div id="joinToast" class="join-toast" role="status" aria-live="polite"></div>

  <!-- üèÅ Duel result panel (shown when duel ends) -->
  <div id="duelResult" class="duel-result" hidden>
    <div class="duel-result__card">
      <div class="duel-result__title">Duel Finished</div>
      <div class="duel-result__winner" id="duelResultWinner"></div>
      <div class="duel-result__reason" id="duelResultReason"></div>
      <button id="duelResultClose" class="duel-result__close" type="button">Close</button>
    </div>
  </div>

  <!-- üîä Background music -->
  <audio
    id="spec-bgm"
    src="audio/bg/Follow the Trail.mp3"
    autoplay
    muted
    playsinline
    loop
    preload="auto"></audio>
  <button id="specAudioToggle" class="audio-toggle" aria-label="Mute background music">üîá</button>

  <script>
    // Autoplay-safe music control (hardened; won't block other scripts if it fails)
    (function setupSpectatorMusic() {
      try {
        const audio = document.getElementById('spec-bgm');
        const btn   = document.getElementById('specAudioToggle');
        if (!audio || !btn) return;

        const STORE_KEY = 'sv13_spectator_bgm.muted';

        // Restore saved preference
        try {
          const stored = localStorage.getItem(STORE_KEY);
          if (stored !== null) audio.muted = (stored === 'true');
        } catch {}

        updateBtn();
        audio.play().catch(() => { /* will unlock on first gesture */ });

        // First user gesture: ensure playback; unmute unless user previously chose mute
        const unlock = () => {
          audio.play().catch(() => {});
          try {
            if (localStorage.getItem(STORE_KEY) !== 'true') {
              audio.muted = false;
              audio.volume = 1;
              updateBtn();
            }
          } catch {}
          cleanupUnlock();
        };
        function cleanupUnlock() {
          window.removeEventListener('pointerdown', unlock, opt);
          window.removeEventListener('keydown', unlock);
          document.removeEventListener('visibilitychange', vis);
        }
        const opt = { passive: true };
        window.addEventListener('pointerdown', unlock, opt);
        window.addEventListener('keydown', unlock);

        // Safari quirk: retry when tab becomes visible
        const vis = () => { if (!document.hidden) audio.play().catch(() => {}); };
        document.addEventListener('visibilitychange', vis);

        // Manual toggle ‚Äî flips muted + volume; click + touch
        const toggle = () => {
          const willMute = !audio.muted;
          audio.muted = willMute;
          audio.volume = willMute ? 0 : 1;
          try { localStorage.setItem(STORE_KEY, String(audio.muted)); } catch {}
          updateBtn();
          audio.play().catch(() => {}); // keep playback active on unmute
        };
        btn.addEventListener('click', toggle);
        btn.addEventListener('touchend', (e) => { e.preventDefault(); toggle(); }, { passive: false });

        function updateBtn() {
          btn.textContent = audio.muted ? 'üîá' : 'üîä';
          btn.setAttribute('aria-label', audio.muted ? 'Play background music' : 'Mute background music');
        }
      } catch (err) {
        console.error('[Spectator] BGM init failed:', err);
      }
    })();

    // üîµ Flash turn display blue whenever its text changes
    (function flashTurnOnUpdate() {
      try {
        const el = document.getElementById('turn-display');
        if (!el) return;
        const applyFlash = () => {
          el.classList.add('highlight-blue','flash-blue');
          setTimeout(() => el.classList.remove('flash-blue'), 1600);
        };
        // initial nudge in case first write happens immediately
        setTimeout(applyFlash, 200);
        const mo = new MutationObserver(applyFlash);
        mo.observe(el, { childList: true, characterData: true, subtree: true });
      } catch (err) {
        console.error('[Spectator] Turn highlighter failed:', err);
      }
    })();

    // üîî Join toast: show "@name has joined the madness" for 10s (triggered by chatClient.js dispatch)
    (function joinToastListener() {
      try {
        const mount = document.getElementById('joinToast');
        if (!mount) return;

        let hideTimer = null;
        const show = (name) => {
          const safe = String(name || 'A player');
          mount.textContent = `@${safe} has joined the madness`;
          mount.classList.add('show','highlight-blue');
          clearTimeout(hideTimer);
          hideTimer = setTimeout(() => {
            mount.classList.remove('show','highlight-blue');
          }, 10000);
        };

        window.addEventListener('spectator:user_joined', (e) => show(e.detail?.name));
      } catch (err) {
        console.error('[Spectator] Join toast failed:', err);
      }
    })();

    // üèÅ Duel result panel listener ‚Äî custom event from chatClient.js OR fallback detector below
    (function duelResultListener(){
      try {
        const wrap   = document.getElementById('duelResult');
        const winner = document.getElementById('duelResultWinner');
        const reason = document.getElementById('duelResultReason');
        const close  = document.getElementById('duelResultClose');
        if (!wrap || !winner || !reason || !close) return;

        let shown = false;

        function show(payload){
          if (shown) return; // show once
          shown = true;
          const w = payload?.winner || payload?.winnerName || 'Unknown';
          const r = payload?.reason || payload?.summary || '';
          winner.textContent = `Winner: ${w}`;
          reason.textContent = r ? String(r) : '';
          wrap.hidden = false;
          wrap.classList.add('show');
        }
        function hide(){
          wrap.classList.remove('show');
          wrap.hidden = true;
        }
        close.addEventListener('click', hide);
        wrap.addEventListener('click', (e) => { if (e.target === wrap) hide(); });

        // Server-driven path
        window.addEventListener('spectator:duel_result', (e) => show(e.detail || {}));

        // Client-side fallback: detect HP==0 and infer winner
        const p1hp = document.getElementById('player1-hp');
        const p2hp = document.getElementById('player2-hp');
        const p1n  = document.getElementById('player1-name');
        const p2n  = document.getElementById('player2-name');
        if (p1hp && p2hp) {
          const infer = () => {
            if (shown) return;
            const h1 = parseInt((p1hp.textContent || '0').replace(/\D+/g,''), 10) || 0;
            const h2 = parseInt((p2hp.textContent || '0').replace(/\D+/g,''), 10) || 0;
            if (h1 <= 0 && h2 > 0) {
              show({ winner: (p2n?.textContent || 'Opponent'), reason: 'HP reached 0' });
            } else if (h2 <= 0 && h1 > 0) {
              show({ winner: (p1n?.textContent || 'Challenger'), reason: 'HP reached 0' });
            }
          };
          // Observe changes to HP spans
          const mo = new MutationObserver(infer);
          mo.observe(p1hp, { childList: true, characterData: true, subtree: true });
          mo.observe(p2hp, { childList: true, characterData: true, subtree: true });
          // Initial check
          setTimeout(infer, 250);
        }
      } catch (err) {
        console.error('[Spectator] Duel result listener failed:', err);
      }
    })();
  </script>

  <!-- ‚Ü© Return to Hub button (preserves token + api, override with ?hub=) -->
  <a id="hubBtn" class="hub-btn" href="#" role="button">‚Ü© Return to Hub</a>
  <script>
    (function setHubLink(){
      try {
        const qs = new URLSearchParams(location.search);

        // Prefer explicit token in window / query / localStorage, then normalize
        let token = (window.PLAYER_TOKEN || qs.get('token') || '');
        if (!token) {
          try { token = localStorage.getItem('sv13.token') || ''; } catch {}
        }
        // Strip leading "Bearer " if present
        if (token && /^Bearer\s+/i.test(token)) token = token.replace(/^Bearer\s+/i, '');

        // API base the hub can reuse
        const api = (window.API_BASE || qs.get('api') || '').replace(/\/+$/, '');

        // allow override via ?hub=<url> ‚Äî normalize trailing slash (no doubles)
        const rawHub = qs.get('hub') || 'https://madv313.github.io/HUB-UI/';
        const hub = rawHub.replace(/\/+$/, '/') || '/';
        const url = new URL(hub);

        // Put params the hub will look for
        if (token) url.searchParams.set('token', token);
        if (api)   url.searchParams.set('api', api);

        // Redundant copy in the hash too, for hubs that only read location.hash
        const hash = new URLSearchParams(url.hash.replace(/^#/, ''));
        if (token && !hash.get('token')) hash.set('token', token);
        if (api && !hash.get('api'))     hash.set('api', api);
        url.hash = hash.toString() ? ('#' + hash.toString()) : '';

        const el = document.getElementById('hubBtn');
        if (el) {
          el.href = url.toString();
          console.log('[HubLink]', el.href);
        }
      } catch (err) {
        console.error('[Spectator] setHubLink failed:', err);
      }
    })();
  </script>

  <!-- Existing spectator logic (non-module) -->
  <script src="scripts/spectatorview.js" defer></script>

  <!-- ‚úÖ Ensure Socket.IO client is present as a global (works even if ESM import fails) -->
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous" defer></script>

  <!-- Realtime chat client (module) -->
  <script type="module" src="scripts/chatClient.js" defer></script>

  <!-- Strong sync: keep "Spectators Watching" in lockstep with chat presence -->
  <script>
  (function strongPresenceSync(){
    let last = null;

    const $ = (id) => document.getElementById(id);
    const watch = () => $('watching-count');
    const pres  = () => $('chat-presence');

    function parseNum(text){
      const m = String(text||'').match(/\d+/);
      return m ? Number(m[0]) : 0;
    }

    function render(n){
      if (!Number.isFinite(n)) n = 0;
      last = n;
      const w = watch(); if (w) w.textContent = `Spectators Watching: ${n}`;
      const p = pres();  if (p) p.textContent = `${n} online`;
    }

    // 1) Trust chatClient's event as the source of truth
    window.addEventListener('spectator:presence', (e) => {
      const n = Number(e.detail && e.detail.count);
      if (Number.isFinite(n)) render(n);
    });

    // 2) If any other script resets either label, snap it back
    const mo = new MutationObserver(() => {
      const wNum = parseNum(watch()?.textContent);
      const pNum = parseNum(pres()?.textContent);
      const cand = Number.isFinite(pNum) ? pNum : wNum;

      if (last === null || (Number.isFinite(cand) && cand !== last)) {
        render(cand);
      } else {
        render(last);
      }
    });

    const startObs = () => {
      const w = watch(); const p = pres();
      if (w) mo.observe(w, { childList:true, characterData:true, subtree:true });
      if (p) mo.observe(p, { childList:true, characterData:true, subtree:true });
    };

    // 3) Initial value (fallback to whatever chat-presence shows on load)
    const initial = parseNum(pres()?.textContent);
    render(initial);

    // 4) Start observers after DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', startObs, { once:true });
    } else {
      startObs();
    }

    // 5) Belt & suspenders: periodic sanity sync (lightweight)
    setInterval(() => { if (last !== null) render(last); }, 5000);
  })();
  </script>

  <!-- Emergency: make sure no overlay is eating clicks -->
  <script>
    (function unblockClicks() {
      try {
        const ids = ['coinFlipContainer', 'announcement'];
        ids.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.pointerEvents = 'none';
        });
        const snow = document.querySelector('.snowfall');
        if (snow) snow.style.pointerEvents = 'none';
      } catch {}
    })();
  </script>
</body>
</html>
